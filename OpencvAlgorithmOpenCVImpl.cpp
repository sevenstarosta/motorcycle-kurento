/* Autogenerated with kurento-module-creator */

#include "OpencvAlgorithmOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


namespace kurento
{
  namespace module
  {
    namespace opencvalgorithm
    {


      void callLog(std::string log){
	std::ofstream file;
	file.open("/tmp/kurento.log",std::ofstream::app);
	file << log << std::endl;
	file.close();
      }

      //-----------------------------CONSTRUCTOR AND DESTRUCTOR--------------------------------
      OpencvAlgorithmOpenCVImpl::OpencvAlgorithmOpenCVImpl ()
      {
	this->MAX_BUFF_SIZE = 60;
	this->TIME_TO_REC = 4;
	this->frameCounter = 0;
	this->recording = false;
	this->start = false;
	this->transientFrame = 0; 
	this->eventEnable = false;
	this->timeToRec = 0;
	
	this->motoCount = 0;
	this->zigzagcount = 0;
	this->carcount = 0;
	this->DETECT_RATE = 4;
	this->MAX_ITER = 3;
	this->MS_EPSILON = 1;
	this->SAVE_RATE = 1000;
	this->MIN_VELOCITY = 6;
	this->MIN_THRESH = 27;
	this->INIT_IMAGES = 200;
	this->length_kmeters = 15;

	this->filter_type = 0;
    
	this->X_SIZE = 400;
	this->Y_SIZE = 400;
	this->MAX_WIDTH = X_SIZE / 6;
	this->MAX_HEIGHT = Y_SIZE / 3;
	this->MIN_HEIGHT = Y_SIZE / 8;
	this->MIN_WIDTH = X_SIZE / 14;

	this->transform_matrix = (cv::Mat_<float>(3,3) << .8, .78, -636, -.256, .994, -243, -.00019, -.00816, 1);
	
	this->image_values = new unsigned char [INIT_IMAGES * X_SIZE * Y_SIZE];


	this->criteria = cv::TermCriteria(MAX_ITER,MAX_ITER,MS_EPSILON);
    
	this->_time = clock();
      }

      OpencvAlgorithmOpenCVImpl::~OpencvAlgorithmOpenCVImpl()
      {
	   while(!this->imgBuffer.empty())
	   {
	        cv::Mat *rem = this->imgBuffer.front();
	       this->imgBuffer.pop();
	       delete rem;
	   }
	   delete [] image_values;
      }

      //-----------------------------FUNCTIONS OF GLOBAL EVENTS--------------------------------


      void OpencvAlgorithmOpenCVImpl::callEvent(std::string type,std::string value){
	this->event->setCodeType(type);
	this->event->setValue(value);
	this->signalCodeFound(*event);
      }

      bool OpencvAlgorithmOpenCVImpl::startRecord()
      {
	if(this->eventEnable)
	  {
	    callEvent("StartRecord","0");
	    this->recording = true;
	    return true;
	  }
	return false;
      }

      bool OpencvAlgorithmOpenCVImpl::stopRecord()
      {
	if(this->eventEnable)
	  {
	    callEvent("StopRecord","1");
	    this->recording = false;
	    return true;
	  }
	return false;
      }

      void OpencvAlgorithmOpenCVImpl::setOpencvAlgorithmType(int type)
      {
	this->filter_type = type;
      }

    void OpencvAlgorithmOpenCVImpl::setMaxBufferSize (int size)
      {
	   this->MAX_BUFF_SIZE = size;
      }
    void OpencvAlgorithmOpenCVImpl::setMaxTimeToRec(int time)
      { 
	   this->TIME_TO_REC = time;
      }

    void OpencvAlgorithmOpenCVImpl::setPoints(int x0, int x1,int x2,int x3,int y0,int y1,int y2,int y3)
      {
         //Prevent second homography from being used
         if(!start)
         {
            cv::Point2f source_points[] = {cv::Point2f(x0-70,y0),cv::Point2f(x1-70,y1),cv::Point2f(x2-70,y2),cv::Point2f(x3-70,y3)};   
            cv::Point2f dst_points[] = {cv::Point2f(0,0), cv::Point2f(X_SIZE,0),cv::Point2f(X_SIZE,Y_SIZE),cv::Point2f(0,Y_SIZE)};
            transform_matrix = cv::getPerspectiveTransform(source_points,dst_points);
            //use inverse matrix to get image back to original
            inverse_matrix = cv::getPerspectiveTransform(dst_points,source_points);
            start = true;
        }
      }

      //---------------------------LOCAL OPENCV FUNCTIONS------------------------------------------


      /*cv::Rect resize_rect(cv::Rect rect, float sf){
	int h = rect.height/sf;
	int w = rect.width/sf;
	int x = rect.x/sf;
	int y = rect.y/sf;
        
	return cv::Rect(x,y,w,h);
	}

	void crop_img(cv::Mat &src, cv::Mat& dst, cv::Rect rect){
	dst = src(rect);
	}

	void and_operation(cv::Mat &src1, cv::Mat &src2, cv::Mat &out){
    
	int w,h;

	if(src1.rows > src2.rows){
        h = src2.rows-1;
	}
	else
        h = src1.rows-1;

	if(src1.cols > src2.cols){
        w = src2.cols-1;
	}
	else
        w = src1.cols-1;

	cv::Mat aux(h,w,CV_8UC1);

	for(int i=0;i<h;i++){
        for(int j=0;j<w;j++){
	if(src1.at<uchar>(i,j)*src2.at<uchar>(i,j) > 0)
	aux.at<uchar>(i,j) = 255;
	else
	aux.at<uchar>(i,j) = 0;    
        }
	}
    
	aux.copyTo(out);

	}

	*/


      //-------------------------MAIN OPENCV ALGORITHMS------------------------------------------

     


      void OpencvAlgorithmOpenCVImpl::Erosion(cv::Mat &img, int radius)
      {
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2*radius+1,2*radius+1),cv::Point(radius,radius));
	cv::erode(img,img,element);
      }

      void OpencvAlgorithmOpenCVImpl::Dilation(cv::Mat &img, int radius)
      {
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2*radius+1,2*radius+1),cv::Point(radius,radius));
	cv::dilate(img,img,element);
      }

      void OpencvAlgorithmOpenCVImpl::Contours(cv::Mat &img)
      {
	cv::Mat canny_output;
	cv::Rect ROI;
	std::vector<std::vector<cv::Point> > contours;
	std::vector<cv::Vec4i> hierarchy;
    
	cv::Canny(img, canny_output, 100, 200, 3);
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(3,3));
	cv::morphologyEx(canny_output, canny_output, cv::MORPH_CLOSE, element);
	cv::findContours(canny_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0,0) );
    
	for(unsigned int i =0; i < contours.size(); i++ )
	  {
	    if (arcLength(contours.at(i),true) > 70)
	      { 
		ROI = cv::boundingRect(contours.at(i));
	    
		//only choosing boxes of desired size. First for motorcycles
		if (ROI.width < MAX_WIDTH && ROI.height > MIN_HEIGHT && ROI.width > MIN_WIDTH && ROI.height < MAX_HEIGHT && ROI.width < (ROI.height+15))
		  {
		    this->objects.push_back(ROI);
		    if (ROI.y > 2 * img.rows / 3)
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,true,true));
            else
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,true,false));
		    //this->initial_pos.push_back(ROI.y);
		    //this->initial_x.push_back(ROI.x);
		    //this->vehicleType.push_back(true);
		  }
		//now checking for larger vehicles
		else if(ROI.width >= MAX_WIDTH && ROI.height > MIN_HEIGHT)
		  {
		      this->objects.push_back(ROI);
		      if (ROI.y > 2 * img.rows / 3)
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,false,true));
            else
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,false,false));
		    //this->initial_pos.push_back(ROI.y);
		    //this->initial_x.push_back(ROI.x);
		    //this->vehicleType.push_back(false);
		  }
	      }
	  }
      }

      /*
	Esta função sera chamada toda vez que houver um novo frame vindo da fonte de video.
	Todo o processamento das imagens devera ser feito nesta funcao.
	Funcoes auxiliares podem ser construidas para auxiliar na oranizacao do codigo.
	Para enviar a referencia da matriz (frame) original para outras funcoes, e necessario
	declarar a variavel como um ponteiro (cv::Mat &mat).
	As funcoes que necessitam acesso a variaveis globais deverao pertencer ao namespace do
	contexto global, neste caso OpencvAlgorithmOpenCVImpl
      */

    void OpencvAlgorithmOpenCVImpl::process (cv::Mat &mat)
      {
        if(start)
        {
	       //perform perspective transform on mat
	       //dst holds color version. must rescale to original.
	       cv::warpPerspective(mat,dst,transform_matrix,cv::Size(X_SIZE,Y_SIZE));
	       cv::cvtColor(dst,frame,CV_BGR2GRAY);
    
	       //initialize background
	       if(frameCounter % SAVE_RATE == 0)
	       {
	        //allocate median array
	           if(average.rows == 0 || average.cols == 0)
	           {
		          frame.copyTo(average);
	           }
	       }
	       //save images into background
	       if (frameCounter % SAVE_RATE < INIT_IMAGES)
	       {
	            for (int y = 0; y < Y_SIZE; y ++)
	           {
		          for (int x = 0; x < X_SIZE; x++)
		          {
		              //image_values[Y_SIZE*X_SIZE*(frameCounter % SAVE_RATE) + X_SIZE * y + x] = frame.at<uchar>(x,y);
		              image_values[X_SIZE*INIT_IMAGES*y + INIT_IMAGES * x + (frameCounter % SAVE_RATE)] = frame.at<uchar>(x,y);
		          }
	           } 
	       }
	       //sort stored images, then extract median image and save it in average
	       if (frameCounter % SAVE_RATE == INIT_IMAGES)
	       {
	           for (int y = 0; y < Y_SIZE; y++)
	           {
    	           for (int x = 0; x < X_SIZE; x++)
	      	        {
                        int offset = X_SIZE * INIT_IMAGES * y + INIT_IMAGES * x;
                        std::sort(image_values + offset, image_values + offset + INIT_IMAGES);
		            }
	           }

	           for (int y = 0; y < Y_SIZE; y++)
	           {
		          for (int x = 0; x < X_SIZE; x++)
		          {
		              average.at<uchar>(x,y) = image_values[X_SIZE * INIT_IMAGES * y + INIT_IMAGES * x + INIT_IMAGES / 2];
		          }
	           }
	       }

	       //main detection script here:
	       if(frameCounter > SAVE_RATE)
	       {
	           cv::absdiff(frame,average,fgMask);
	           Erosion(fgMask,3);
	           Dilation(fgMask,4);
	           cv::threshold(fgMask,fgMask,MIN_THRESH,255,3);
	           //preprocessing complete ----------------------------------------------------------------------
	  
	           //counting vehicles that have passed the half way point
	           //this->previousVehicles = this->passedVehicles;
	           //this->passedVehicles.clear();
	           
	           if (frameCounter % DETECT_RATE == DETECT_RATE / 2)
                {
                    for (unsigned int j = 0; j < objects.size(); j++)
                    {
                        vehicles.at(j).second_x = objects.at(j).x;
                    }
                }

	           for (unsigned int j =0; j < this->objects.size(); j++)
	           {
		          /// Update each tracked object using mean shift?
		          cv::meanShift(fgMask, this->objects.at(j),this->criteria);
		          this->objects.at(j) = this->objects.at(j) & cv::Rect(0,0,frame.cols, frame.rows);
	  
		          //count passed motorcycles
		          if((this->objects.at(j).y >= (2*frame.rows/3) ) && this->vehicles.at(j).type)
		          {
		              //this->passedVehicles.push_back(true);
	      
		              // filled with dummy values to prevent out of bounds error
		              //for (unsigned int k = this->previousVehicles.size(); k<= j; k++)
		              //  this->previousVehicles.push_back(true);
		              
		              //do all counting here
		              //if( !this->previousVehicles.at(j) )
		              if (!this->vehicles.at(j).over_line)
		              {
			             motoCount++;
			             if ( vehicles.at(j).type && ( (vehicles.at(j).second_x - vehicles.at(j).initial_x) * (objects.at(j).x - vehicles.at(j).second_x) < -10))
                        {
                            zigzagcount++;
                        }
		              }
		              this->vehicles.at(j).over_line = true;
		          }
		          else if(this->objects.at(j).y >= (2*frame.rows/3))
		          {
		              if(!this->vehicles.at(j).over_line)
		              {
		                  this->vehicles.at(j).over_line = true;
		                  carcount++;
		              }
		          }
		          //else if (this->vehicles.at(j).type)
		          //{
		          //    this->passedVehicles.push_back(false);
		          //}

		          if (frameCounter % DETECT_RATE == 0 && (this->objects.at(j).y + this->objects.at(j).height < frame.rows - 4))
		          {
		              //by framerate in video. may be encoded inaccurately.
		              double velocity = 3600 * ((double) frameRate / (double) DETECT_RATE) * (objects.at(j).y - vehicles.at(j).initial_y) * length_kmeters / frame.rows;
		    
	      
		              //discard false positives and vehicles lost by the tracker
		              if (velocity > MIN_VELOCITY && this->vehicles.at(j).type)
		              {
			             this->moto_velocities.push_back(velocity);
		              }
		              //Not motorycle
		              else if (velocity > MIN_VELOCITY)
		              {
			             this->car_velocities.push_back(velocity);
		              }
		          }

		          //drawing tracked rectangle on original image
		          //motorcycle
		          if (this->vehicles.at(j).type)
		          {
		              cv::rectangle(dst, this->objects.at(j), cv::Scalar(255,0,0),2,1);
		          }
		          //other vehicles
		          else
		          {
		              cv::rectangle(dst, this->objects.at(j), cv::Scalar(0,0,255),2,1);
		          }	  
	           }
	           if (frameCounter % DETECT_RATE ==0)
	           {	
	               this->vehicles.clear();      
		          //this->previousVehicles.clear();
		          //this->initial_pos.clear();
		          //this->initial_x.clear();
		          //this->vehicleType.clear();
		          this->objects.clear();
	      
		          Contours(fgMask);

		          //put in locations of previous vehicles for counting
		          /*for (unsigned int j =0; j < this->objects.size(); j++)
		          {
		              //count passed motorcycles
		              if((this->objects.at(j).y >= (2*frame.rows/3) ) && this->vehicleType.at(j))
		              {
			             //this->previousVehicles.push_back(true);
		              }
		              else if (this->vehicleType.at(j))
		              {
			             //this->previousVehicles.push_back(false);
		              }
		          }*/
	           }
	           //cv::resize(dst,dst,mat.size());
	       }  
            /*if(frameCounter > TRANSIENT_FRAME){
	           time_t now;
	           time(&now);
    
	           double diff =  difftime(now,_time);
	           this->frameRate = (float)(frameCounter/diff);
    
	           time(&_time);
	           frameCounter = 0;
	       }
  
	       if(transientFrame > TRANSIENT_FRAME)
	       {
	           //Allocate a new image   
	           cv::Mat auxMat;// = new cv::Mat();
	           auxMat = mat.clone();
	       }
	       */
  
	       /*if(moving > frameRate)
	       {
	           timeToRec++;  
	           if(!recording)
	           {
		      startRecord();
	           }
	           else if(recording && timeToRec/frameRate > TIME_TO_REC)
	           {
		          timeToRec = 0;
		          stopRecord();
	           }
	       }
  
	       else if(recording)
	       {
	           stopRecord();
	       }*/
	       
            cv::warpPerspective(dst,mat,inverse_matrix,cv::Size(mat.cols,mat.rows));
            cv::putText(mat,"Motorcycle count: " + std::to_string(motoCount),cv::Point(5,50),0,1,cv::Scalar(255,0,0),2); 
            cv::putText(mat,"Car count: " + std::to_string(carcount),cv::Point(5,110),0,1,cv::Scalar(255,0,0),2); 
            //cv::resize(dst,mat,mat.size());
	       //mat = dst.clone();
	       transientFrame++; 
	       frameCounter++;
	   }
	   else //hasn't yet received homology points, therefore cannot start detection   
	   {
	       frameCounter = 0;
	   }
	 } 
  
      //transientFrame++;
      //frameCounter++;
        //}  

  } /* opencvalgorithm */
} /* module */
} /* kurento */
