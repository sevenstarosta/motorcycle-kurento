/* Autogenerated with kurento-module-creator */

#include "OpencvAlgorithmOpenCVImpl.hpp"
#include <KurentoException.hpp>
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"


namespace kurento
{
  namespace module
  {
    namespace opencvalgorithm
    {


      void callLog(std::string log){
	std::ofstream file;
	file.open("/tmp/kurento.log",std::ofstream::app);
	file << log << std::endl;
	file.close();
      }

      //-----------------------------CONSTRUCTOR AND DESTRUCTOR--------------------------------
      OpencvAlgorithmOpenCVImpl::OpencvAlgorithmOpenCVImpl ()
      {
	this->MAX_BUFF_SIZE = 60;
	this->TIME_TO_REC = 4;
	this->frameCounter = 0;
	this->recording = false;
	this->start = 0;
	this->transientFrame = 0; 
	this->eventEnable = false;
	this->timeToRec = 0;
	this->setPointsCounter = 0;
	
	this->motoCount = 0;
	this->zigzagcount = 0;
	this->carcount = 0;
	this->DETECT_RATE = 4;
	this->MAX_ITER = 3;
	this->MS_EPSILON = 1;
	this->SAVE_RATE = 1000;
	this->MIN_VELOCITY = 6;
	this->MIN_THRESH = 27;
	this->INIT_IMAGES = 200;
	this->length_kmeters = 15;
    this->average_moto_velocity = 0;
    this->average_car_velocity = 0;

	this->filter_type = 0;
    
	this->X_SIZE = 400;
	this->Y_SIZE = 400;
	this->MAX_WIDTH = X_SIZE / 7;
	this->MAX_HEIGHT = Y_SIZE / 3;
	this->MIN_HEIGHT = Y_SIZE / 11;
	this->MIN_WIDTH = X_SIZE / 16;

	this->transform_matrix = (cv::Mat_<float>(3,3) << .8, .78, -636, -.256, .994, -243, -.00019, -.00816, 1);
	
	this->image_values = new unsigned char [INIT_IMAGES * X_SIZE * Y_SIZE];


	this->criteria = cv::TermCriteria(MAX_ITER,MAX_ITER,MS_EPSILON);
    
	this->_time = clock();
      }

      OpencvAlgorithmOpenCVImpl::~OpencvAlgorithmOpenCVImpl()
      {
	   while(!this->imgBuffer.empty())
	   {
	        cv::Mat *rem = this->imgBuffer.front();
	       this->imgBuffer.pop();
	       delete rem;
	   }
	   delete [] image_values;
      }

      //-----------------------------FUNCTIONS OF GLOBAL EVENTS--------------------------------


    void OpencvAlgorithmOpenCVImpl::callEvent(std::string type,std::string value){
	   this->event->setCodeType(type);
	   this->event->setValue(value);
	   this->signalCodeFound(*event);
      }

      bool OpencvAlgorithmOpenCVImpl::startRecord()
      {
	if(this->eventEnable)
	  {
	    callEvent("StartRecord","0");
	    this->recording = true;
	    return true;
	  }
	return false;
      }

      bool OpencvAlgorithmOpenCVImpl::stopRecord()
      {
	if(this->eventEnable)
	  {
	    callEvent("StopRecord","1");
	    this->recording = false;
	    return true;
	  }
	return false;
      }

      void OpencvAlgorithmOpenCVImpl::setOpencvAlgorithmType(int type)
      {
	this->filter_type = type;
      }

    void OpencvAlgorithmOpenCVImpl::setMaxBufferSize (int size)
      {
	   this->MAX_BUFF_SIZE = size;
      }
    void OpencvAlgorithmOpenCVImpl::setMaxTimeToRec(int time)
      { 
	   this->TIME_TO_REC = time;
      }

    void OpencvAlgorithmOpenCVImpl::setPoints(int x0, int x1,int x2,int x3,int y0,int y1,int y2,int y3, int start)
      {
         //Prevent second homography from being used
         if(!this->start)
         {
            callLog(std::to_string(this->start));
            
         
            this->start = start;
            
            if(this->setPointsCounter == 0)
            {  
                cv::Point2f source_points[] = {cv::Point2f(x0,y0),cv::Point2f(x1,y1),cv::Point2f(x2,y2),cv::Point2f(x3,y3)};   
                cv::Point2f dst_points[] = {cv::Point2f(0,0), cv::Point2f(X_SIZE,0),cv::Point2f(X_SIZE,Y_SIZE),cv::Point2f(0,Y_SIZE)};
                transform_matrix = cv::getPerspectiveTransform(source_points,dst_points);
                //use inverse matrix to get image back to original
                inverse_matrix = cv::getPerspectiveTransform(dst_points,source_points);
            }
            else
            {
                prohibitedAreas.push_back(cv::Point2f(x0,y0));
                prohibitedAreas.push_back(cv::Point2f(x1,y1));
                prohibitedAreas.push_back(cv::Point2f(x2,y2));
                prohibitedAreas.push_back(cv::Point2f(x3,y3));
            }
            
            
            setPointsCounter++;
            
        }
      }

      //---------------------------LOCAL OPENCV FUNCTIONS------------------------------------------

	void and_operation(cv::Mat &src1, cv::Mat &src2, cv::Mat &out)
	{
    
	   int w,h;

	   if(src1.rows > src2.rows){
         h = src2.rows-1;
	   }
	   else
         h = src1.rows-1;

	   if(src1.cols > src2.cols){
        w = src2.cols-1;
	   }
	   else
        w = src1.cols-1;

	   cv::Mat aux(h,w,CV_8UC1);

	   for(int i=0;i<h;i++){
         for(int j=0;j<w;j++){
	   if(src1.at<uchar>(i,j)*src2.at<uchar>(i,j) > 0)
	   aux.at<uchar>(i,j) = 255;
	   else
	   aux.at<uchar>(i,j) = 0;    
        }
	   }
    
	   aux.copyTo(out);

	}

      //-------------------------MAIN OPENCV ALGORITHMS------------------------------------------

     


      void OpencvAlgorithmOpenCVImpl::Erosion(cv::Mat &img, int radius)
      {
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2*radius+1,2*radius+1),cv::Point(radius,radius));
	cv::erode(img,img,element);
      }

      void OpencvAlgorithmOpenCVImpl::Dilation(cv::Mat &img, int radius)
      {
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(2*radius+1,2*radius+1),cv::Point(radius,radius));
	cv::dilate(img,img,element);
      }

      void OpencvAlgorithmOpenCVImpl::Contours(cv::Mat &img)
      {
	cv::Mat canny_output;
	cv::Rect ROI;
	std::vector<std::vector<cv::Point> > contours;
	std::vector<cv::Vec4i> hierarchy;
    
	cv::Canny(img, canny_output, 100, 200, 3);
	cv::Mat element = cv::getStructuringElement(cv::MORPH_ELLIPSE,cv::Size(3,3));
	cv::morphologyEx(canny_output, canny_output, cv::MORPH_CLOSE, element);
	cv::findContours(canny_output, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE, cv::Point(0,0) );
    
	for(unsigned int i =0; i < contours.size(); i++ )
	  {
	    if (arcLength(contours.at(i),true) > 70)
	      { 
		ROI = cv::boundingRect(contours.at(i));
	    
		//only choosing boxes of desired size. First for motorcycles
		if (ROI.width < MAX_WIDTH && ROI.height > MIN_HEIGHT && ROI.width > MIN_WIDTH && ROI.height < MAX_HEIGHT && ROI.width < (ROI.height+15))
		  {
		    this->objects.push_back(ROI);
		    if (ROI.y > 2 * img.rows / 3)
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,true,true));
            else
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,true,false));
		    //this->initial_pos.push_back(ROI.y);
		    //this->initial_x.push_back(ROI.x);
		    //this->vehicleType.push_back(true);
		  }
		//now checking for larger vehicles
		else if(ROI.width >= MAX_WIDTH && ROI.height > MIN_HEIGHT)
		  {
		      this->objects.push_back(ROI);
		      if (ROI.y > 2 * img.rows / 3)
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,false,true));
            else
                this->vehicles.push_back(vehicle(ROI.y,ROI.x,ROI.x,false,false));
		    //this->initial_pos.push_back(ROI.y);
		    //this->initial_x.push_back(ROI.x);
		    //this->vehicleType.push_back(false);
		  }
	      }
	  }
      }

      /*
	Esta função sera chamada toda vez que houver um novo frame vindo da fonte de video.
	Todo o processamento das imagens devera ser feito nesta funcao.
	Funcoes auxiliares podem ser construidas para auxiliar na oranizacao do codigo.
	Para enviar a referencia da matriz (frame) original para outras funcoes, e necessario
	declarar a variavel como um ponteiro (cv::Mat &mat).
	As funcoes que necessitam acesso a variaveis globais deverao pertencer ao namespace do
	contexto global, neste caso OpencvAlgorithmOpenCVImpl
      */

    void OpencvAlgorithmOpenCVImpl::process (cv::Mat &mat)
      {
        
      
      
        if(this->start)
        {
	       //perform perspective transform on mat
	       //dst holds color version. must rescale to original.
	       cv::warpPerspective(mat,dst,transform_matrix,cv::Size(X_SIZE,Y_SIZE));
	       cv::cvtColor(dst,frame,CV_BGR2GRAY);
    
	       //initialize background
	       if(frameCounter % SAVE_RATE == 0)
	       {
	        //allocate median array
	           if(average.rows == 0 || average.cols == 0)
	           {
		          frame.copyTo(average);
	           }
	       }
	       //save images into background
	       if (frameCounter % SAVE_RATE < INIT_IMAGES)
	       {
	            for (int y = 0; y < Y_SIZE; y ++)
	           {
		          for (int x = 0; x < X_SIZE; x++)
		          {
		              //image_values[Y_SIZE*X_SIZE*(frameCounter % SAVE_RATE) + X_SIZE * y + x] = frame.at<uchar>(x,y);
		              image_values[X_SIZE*INIT_IMAGES*y + INIT_IMAGES * x + (frameCounter % SAVE_RATE)] = frame.at<uchar>(x,y);
		          }
	           } 
	       }
	       //sort stored images, then extract median image and save it in average
	       if (frameCounter % SAVE_RATE == INIT_IMAGES)
	       {
	           for (int y = 0; y < Y_SIZE; y++)
	           {
    	           for (int x = 0; x < X_SIZE; x++)
	      	        {
                        int offset = X_SIZE * INIT_IMAGES * y + INIT_IMAGES * x;
                        std::sort(image_values + offset, image_values + offset + INIT_IMAGES);
		            }
	           }

	           for (int y = 0; y < Y_SIZE; y++)
	           {
		          for (int x = 0; x < X_SIZE; x++)
		          {
		              average.at<uchar>(x,y) = image_values[X_SIZE * INIT_IMAGES * y + INIT_IMAGES * x + INIT_IMAGES / 2];
		          }
	           }
	       }

	       //main detection script here:
	       if(frameCounter > SAVE_RATE)
	       {
	           cv::absdiff(frame,average,fgMask);
	           Erosion(fgMask,3);
	           Dilation(fgMask,4);
	           cv::threshold(fgMask,fgMask,MIN_THRESH,255,3);
	           //preprocessing complete ----------------------------------------------------------------------
	           
	           if (frameCounter % DETECT_RATE == DETECT_RATE / 2)
                {
                    for (unsigned int j = 0; j < objects.size(); j++)
                    {
                        vehicles.at(j).second_x = objects.at(j).x;
                    }
                }

	           for (unsigned int j =0; j < this->objects.size(); j++)
	           {
		          /// Update each tracked object using mean shift?
		          cv::meanShift(fgMask, this->objects.at(j),this->criteria);
		          this->objects.at(j) = this->objects.at(j) & cv::Rect(0,0,frame.cols, frame.rows);
	  
		          //count passed motorcycles
		          if((this->objects.at(j).y >= (2*frame.rows/3) ) && this->vehicles.at(j).type)
		          {   
		              //do all counting here
		              //if( !this->previousVehicles.at(j) )
		              if (!this->vehicles.at(j).over_line)
		              {
			             motoCount++;
			             if ( vehicles.at(j).type && ( (vehicles.at(j).second_x - vehicles.at(j).initial_x) * (objects.at(j).x - vehicles.at(j).second_x) < -10))
                        {
                            zigzagcount++;
                        }
		              }
		              this->vehicles.at(j).over_line = true;
		          }
		          else if(this->objects.at(j).y >= (2*frame.rows/3))
		          {
		              if(!this->vehicles.at(j).over_line)
		              {
		                  this->vehicles.at(j).over_line = true;
		                  carcount++;
		              }
		          }

		          if (frameCounter % DETECT_RATE == 0 && (this->objects.at(j).y + this->objects.at(j).height < frame.rows - 4))
		          {
		              //by framerate in video. may be encoded inaccurately.
		              double velocity = 3600 * ((double) frameRate / (double) DETECT_RATE) * (objects.at(j).y - vehicles.at(j).initial_y) * length_kmeters / frame.rows;
		    
	      
		              //discard false positives and vehicles lost by the tracker
		              if (velocity > MIN_VELOCITY && this->vehicles.at(j).type)
		              {
			             this->moto_velocities.push_back(velocity);
		              }
		              //Not motorycle
		              else if (velocity > MIN_VELOCITY)
		              {
			             this->car_velocities.push_back(velocity);
		              }
		          }

		          //drawing tracked rectangle on original image
		          //motorcycle
		          if (this->vehicles.at(j).type)
		          {
		              cv::rectangle(dst, this->objects.at(j), cv::Scalar(255,0,0),2,1);
		          }
		          //other vehicles
		          else
		          {
		              cv::rectangle(dst, this->objects.at(j), cv::Scalar(0,0,255),2,1);
		          }	  
	           }
	           if (frameCounter % DETECT_RATE ==0)
	           {
                    this->vehicles.clear();      
                    this->objects.clear();
                    Contours(fgMask);
                    //print out average velocity
                    if(frameCounter % (DETECT_RATE * 3) == 0)
                    { 
                        average_moto_velocity = 0;
                        average_car_velocity = 0;
                        for(unsigned int i = 0; i < this->moto_velocities.size(); i++)
                        {
                            average_moto_velocity += this->moto_velocities.at(i);
                        }
                        average_moto_velocity /= (double) this->moto_velocities.size();
      
                        for(unsigned int i = 0; i< this->car_velocities.size(); i++)
                        {
                            average_car_velocity += this->car_velocities.at(i);
                        }
                        average_car_velocity /= (double) this->car_velocities.size();
                        this->moto_velocities.clear();
                        this->car_velocities.clear();
                    }
	           }
	       }  
            cv::warpPerspective(dst,mat,inverse_matrix,cv::Size(mat.cols,mat.rows));
            cv::putText(mat,"Motos: " + std::to_string(motoCount),cv::Point(1,30),0,1,cv::Scalar(255,0,0),2); 
            cv::putText(mat,"Carros: " + std::to_string(carcount),cv::Point(1,60),0,1,cv::Scalar(255,0,0),2);
	       cv::putText(mat,"Zigzag: " + std::to_string(zigzagcount),cv::Point(180,30),0,1,cv::Scalar(255,0,0),2); 
	       
	       //cv::putText(mat,"Moto veloc.: " + std::to_string(average_moto_velocity),cv::Point(180,60),0,1,cv::Scalar(255,0,0),2); 
	       //cv::putText(mat,"Carro veloc.: " + std::to_string(average_car_velocity),cv::Point(1,90),0,1,cv::Scalar(255,0,0),2); 
            //cv::resize(dst,mat,mat.size());
	       //mat = dst.clone();
	       
	       if(this->prohibitedAreas.size() > 0){
    	       unsigned int i;
    	       for(i=0;i<3;i++){
    	           cv::line(mat,this->prohibitedAreas[i],this->prohibitedAreas[i+1],cv::Scalar(255,0,0),1,8,0);
    	       }
	       }
	       
	       
	       transientFrame++; 
	       frameCounter++;
	   }
	   else //hasn't yet received homology points, therefore cannot start detection   
	   {
	       frameCounter = 0;
	   }
	   
	 } 

  } /* opencvalgorithm */
} /* module */
} /* kurento */
